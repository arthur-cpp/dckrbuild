#!/usr/bin/env python3
# vim: sts=4 sw=4 et

import argparse
import dulwich.porcelain
from dulwich.config import ConfigFile, parse_submodules
from dulwich.repo import Repo
from dulwich.objectspec import parse_tree
import io
import os
import pathlib
import shutil
import subprocess
import tempfile
import sys

from debian.deb822 import Sources, Changes
from debian import changelog

parser = argparse.ArgumentParser(description="Build package in docker")
parser.add_argument("dist", type=str, default='ubuntu18.04', help="Distribution to build for")
parser.add_argument("-r", "--reference", type=str, default='HEAD', help="Commit to build")
parser.add_argument("--rebuild", type=str, default='', help="Binary rebuild suffix")
parser.add_argument("-j", dest='jobs', type=int, default=4, help="Parallel jobs")
parser.add_argument("-n", "--dry-run", dest='dry_run', action='store_true', help="Print the commands but do not execute them")
parser.add_argument("--with-network", action='store_true', help="Enable networking during build")
# Add image prefix to match what pyinit generates
parser.add_argument("--prefix", type=str, default='build', help="Image prefix")

args = parser.parse_args()

# Anchor to the current directory (where the project build is initiated)
PROJECT_ROOT = pathlib.Path.cwd()

DISTS = {
    'ubuntu24.04': 'noble',
    'ubuntu22.04': 'jammy',
    'ubuntu20.04': 'focal',
    'ubuntu18.04': 'bionic',
    'debian13': 'trixie',
    'debian12': 'bookworm',
    'debian11': 'bullseye',
    'debian10': 'buster',
}
VDISTS = {v: k for k,v in DISTS.items()}

# Validation: Check if we are in a Debian project root
control_file = PROJECT_ROOT / 'debian/control'
if not control_file.exists():
    print(f"Error: {control_file} not found. Are you in a debian project root?")
    sys.exit(1)

control = Sources(open(control_file))
pkg = control['Source']
dist = DISTS.get(args.dist, args.dist)
vdist = VDISTS[dist]
arch = 'amd64'
# Important: tag must match the one generated by pyinit/prepare
tag = f"build-tmp:{pkg}-{vdist}"

try:
    version = dulwich.porcelain.describe(str(PROJECT_ROOT)).replace('_', '~').replace('%', ':')
    if version.startswith('v'):
        version = version[1:]
except Exception as e:
    print(f"Warning: Could not get version from git: {e}")
    # Fallback to changelog version if git is unavailable
    version = str(changelog.Changelog(open(PROJECT_ROOT / 'debian/changelog')).full_version)

print(f"Package: {pkg}, Version: {version}, Target: {vdist}")

def build_command(tmp):
    cmd = ['timeout', '3600', 'docker', 'run', '--rm']
    
    # Ccache and environment setup
    home_dir = os.environ.get('HOME', '/tmp')
    cmd += [
        f"--mount=type=bind,src={home_dir}/.ccache/,dst=/ccache",
        "--env=CCACHE_DIR=/ccache",
    ]
    
    for e in ['DEB_BUILD_OPTIONS', 'DEB_BUILD_PROFILES']:
        if e in os.environ:
            cmd += [f'--env={e}={os.environ[e]}']

    if args.with_network:
        cmd += ['--net=host']
    else:
        cmd += ['--net=none']
    
    cmd += [f'--user={os.getuid()}:{os.getgid()}']
    cmd += [f"-v{tmp.resolve()}:/build", "-w/build/src"]
    cmd += [tag, "dpkg-buildpackage", "-rfakeroot", "-uc", "-us", "-b", f"-j{args.jobs}"]
    return cmd

def export(dest, ref='HEAD', repo=pathlib.Path('.'), backport=False, submodules=False):
    if not dest.exists():
        dest.mkdir(parents=True)
    
    # Use absolute path to the repository
    repo_abs = pathlib.Path(repo).resolve()
    
    pack = subprocess.Popen(('git', 'archive', '--format=tar', '--prefix=./', ref), 
                            stdout=subprocess.PIPE, cwd=repo_abs)
    if subprocess.run(('tar', 'x'), stdin=pack.stdout, cwd=dest).returncode:
        raise RuntimeError("tar failed")
    pack.wait()
    
    if backport:
        export_pristine_tar(dest)
    if submodules:
        export_submodules(dest, ref, repo_abs)

def export_submodules(dest, ref, repo):
    with Repo(str(repo)) as r:
        try:
            blob = dulwich.porcelain.get_object_by_path(r, '.gitmodules', ref)
        except KeyError:
            return

        for k, url, path in parse_submodules(ConfigFile.from_file(io.BytesIO(blob.data))):
            # Dulwich works with bytes for paths
            path_str = path.decode('utf-8')
            sha = submodule_commit(r, path, ref)
            print(f'Export submodule {path_str}: {sha.decode("ascii")}')
            export(dest / path_str, sha.decode('ascii'), repo=repo / path_str)

def submodule_commit(repo, path, treeish=b"HEAD"):
    tree = parse_tree(repo, treeish)
    mode, sha = tree.lookup_path(repo.get_object, path)
    return sha

def export_pristine_tar(dest):
    # Use PROJECT_ROOT to locate original upstream tarballs
    v = version.split(':', 1)[1] if ':' in version else version
    tags = [x[len(b'upstream/'):].decode('utf-8') for x in dulwich.porcelain.tag_list(str(PROJECT_ROOT)) if x.startswith(b'upstream/')]
    for t in tags:
        if v.startswith(t):
            if subprocess.run(('pristine-tar', 'checkout', f'{dest.parent}/{pkg}_{t}.orig.tar.gz'), cwd=PROJECT_ROOT).returncode:
                print("Warning: pristine-tar failed")
            break

def bump_version(current_version, path, backport=False):
    new_version = current_version + ('~' if backport else '+') + vdist
    if args.rebuild:
        new_version += '+' + args.rebuild
    
    changelog_path = path / 'debian/changelog'
    with open(changelog_path, 'r') as f:
        ch = changelog.Changelog(f)
    
    ch.new_block(
        package=pkg,
        version=new_version,
        distributions=dist,
        urgency='low',
        author="%s <%s>" % changelog.get_maintainer(),
        date=changelog.format_date()
    )
    ch.add_change('\n  * Build version bump for ' + vdist)
    
    with open(changelog_path, 'w') as f:
        f.write(str(ch))
    return new_version

def copy_result(src, dest):
    pkg_changes = f'{pkg}_{version}_{arch}.changes'
    if not dest.exists():
        dest.mkdir(parents=True)
    
    changes_path = src / pkg_changes
    if not changes_path.exists():
        print(f"Error: Changes file {changes_path} not found!")
        return

    changes = Changes(open(changes_path))
    for f in changes['files']:
        fn = f['name']
        dfn = fn
        if fn.endswith('.ddeb'):
            dfn = fn.replace('.ddeb', '.deb')
            # Fix logic inside changes object if persistence is needed
        
        print(f'Copying {fn} to {dest}')
        shutil.copy2(src / fn, dest / dfn)

# --- Main Logic ---

# Check if backport is needed (presence of pristine-tar branch)
try:
    backport = b'refs/heads/pristine-tar' in Repo(str(PROJECT_ROOT)).refs.keys()
except:
    backport = False

with tempfile.TemporaryDirectory(dir=os.path.expanduser('~/tmp')) as tmpdir:
    tmp = pathlib.Path(tmpdir)
    export(tmp / 'src', ref=args.reference, repo=PROJECT_ROOT, backport=backport, submodules=True)
    
    version = bump_version(version, tmp / 'src', backport)
    
    cmd = build_command(tmp)
    if args.dry_run:
        print(' '.join(cmd))
        sys.exit(0)
        
    print(f"Running build for {vdist}...")
    result = subprocess.run(cmd)
    
    if result.returncode == 0:
        copy_result(tmp, PROJECT_ROOT / 'result' / vdist)
        print(f"Successfully built {vdist}")
    else:
        print(f"Build failed with code {result.returncode}")
        sys.exit(result.returncode)